---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ljc.
--- DateTime: 2020/6/29 9:35
---
--print("hello world")
----全局变量
--aa = "aa ~~"
----局部变量
--local bb = "bb ~~"

--function func1(args)
--    cc = "cc ~~"
--    local dd = "dd ~~"
--    print(args)
--end
--func1(12)
--print(aa)
--print(bb)
--print(cc)
----dd不能输出
--print(dd)

----数据类型
--print(type("hello world")) --string
--print(type(10.4 * 3)) --number
--print(type(type)) --function
--print(type(true)) --boolean
--print(type(nil)) --nil只有值nil属于该类,表示一个无效值(在条件表达式中相当于false)
--print(type(type(X))) --string
--print("----------------------------------------------")
----nil 类型表示一种没有任何有效值,它只有一个值--nil,例如打印一个没有赋值的变量,便会输出一个nil值
--print(a)
--tab1 = {key1 = "value1", key2 = "value2", "value3"}
---- lua脚本中使用..来连接字符串
--for k,v in pairs(tab1) do
--    print(k .."-" .. v)
--end
----对于全局变量和table,nil还有一个"删除"作用,给全局变量或者table表里的变量赋值一个nil值,等同与把他们删除,执行下面代码就知:
--tab1.key1 = nil
--for k,v in pairs(tab1) do
--    print(k .. "-" .. v)
--end
--print("=====")
----nil做比较时候应该加上引号", 因为type(type(Z))返回的类型是string,说明返回的是"nil",而不是nil类型
--print(type(Z))
--print(type(Z) == nil)
--print(type(Z) == "nil")
--print(type(type(Z)))
--print("--------")
----在对一个数字字符串上进行算术操作的时候,lua会尝试将这个数字字符串转化成一个数字
--print("2" + 6)
----print("abc" + 3) 这里报错了,不会再往下面执行了
----字符串连接使用的是..
--print("abcd".."3")
----#来计算字符串的长度
--print(#"abcde")

----创建一个空的table
--local table11 = {}
----直接初始化表
--local table22 = {"apple", "pear", "orange", "grape"}
----lua中的表table其实是一个关联数组(associative arrays),数组的索引可以是数字或者字符串
-- table_test.lua 脚本文件
--a = {}
----a["key"] = "value"
----key = 10
----a[key] = 22
----a[key] = a[key] + 11
----for k,v in pairs(a) do
----    print(k .. " : " .. v)
----end

--local tb1 = {"apple", "pear", "orange", "grape"}
--for key, val in pairs(tb1) do
--    print("key", key)
--end

--流程控制
--a,b = 1,2
--if(a<b) then
--    print("a<b")
--end
--
--if(a>b) then
--    print("a>b")
--else
--    print("a<b")
--end
--
----嵌套
--if(a<b) then
--    if(b>=1) then
--        print("a<b and b>=1")
--    end
--end

--print("---循环---")
--c = 10
--while(c>0) do
--    print(c)
--    c=c-1
--end

--d = 10
--repeat
--    print(d)
--    d = d -1
--until (d<1)
--
--for i = 1, 10, 2 do
--    print(i)
--end

--print("--泛型for循环--")
--arr = {"aa", "bb", 123}
--for i = 1, #arr do
--    print(arr[i])
--end
--arr = {"aa", "bb", 123}
--for i, v in ipairs(arr) do
--    print(i + " : " + v)
--end

--for i, v in pairs(arr) do
--    print(i,v)
--    print(i .. " " .. v)
--end

--类型转换
--print(type(tostring(10)))
--print(type(tostring(true)))
--print(type(tonumber('10')))
--print(type(tonumber("df")))

--
--function fun1(a,b,c)
--    print(a,b,c)
--    return a
--end
--
--a = fun1(1,2,3)
--print(a)

--tb = {name = "zhangsan"}
--tb.age = 25
--print(tb["name"])
--print(tb["age"])
--
--params = {
--    {ip="node1", port=9092},
--    {ip="node2", port=9092}
--}

--require 函数 lua提供了一个名为require的函数来加载模块,要加载一个模块,只需要简单地调用就可以了
--require("module1")
--print(module1.constant)
--print(module1.func3())
--print(module1.func1())

--sss 1.模块名要和文件名一样  2.不能直接调用模块里面的私有函数/变量,需要使用公有函数间接调用

--引入test模块
--require "test"

----拿到引入模块的成员变量
--dpn = _M.default_partition_nums
--print(dpn)
--
----拿到函数
--producer = _M.new()
--print(producer)
--
--send = _M.send()
--print(send)
--
--b = _B
--print(b)

--引入module1模块,sss 实际上引入的是文件名,而不是里面写多少模块名,只需要引入文件名即可,里面的模块都可以调用
require("bd.module122")
print(module11.aa)
